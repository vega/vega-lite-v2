{"version":3,"file":"fielddef.test.js","sourceRoot":"","sources":["../../test/fielddef.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\n\nimport {COUNTING_OPS} from '../src/aggregate';\nimport {Channel} from '../src/channel';\nimport {channelCompatibility, ChannelDef, defaultType, FieldDef, normalize, title, vgField} from '../src/fielddef';\nimport * as log from '../src/log';\nimport {TimeUnit} from '../src/timeunit';\nimport {QUANTITATIVE, TEMPORAL} from '../src/type';\n\ndescribe('fieldDef', () => {\n  describe('vgField()', () => {\n    it ('should access flattened fields', () => {\n      assert.deepEqual(vgField({field: 'foo.bar\\\\.baz'}), 'foo\\\\.bar\\\\.baz');\n    });\n\n    it ('should access flattened fields in expression', () => {\n      assert.deepEqual(vgField({field: 'foo.bar\\\\.baz'}, {expr: 'datum'}), 'datum[\"foo.bar.baz\"]');\n    });\n  });\n\n  describe('defaultType()', () => {\n    it('should return temporal if there is timeUnit', () => {\n      assert.equal(defaultType({timeUnit: 'month', field: 'a'} as FieldDef<string>, 'x'), 'temporal');\n    });\n\n    it('should return quantitative if there is bin', () => {\n      assert.equal(defaultType({bin: true, field: 'a'} as FieldDef<string>, 'x'), 'quantitative');\n    });\n\n    it('should return quantitative for a channel that supports measure', () => {\n      for (const c of ['x', 'y', 'size', 'opacity', 'order'] as Channel[]) {\n        assert.equal(defaultType({field: 'a'} as FieldDef<string>, c), 'quantitative', c);\n      }\n    });\n\n    it('should return nominal for a channel that does not support measure', () => {\n      for (const c of ['color', 'shape', 'row', 'column'] as Channel[]) {\n        assert.equal(defaultType({field: 'a'} as FieldDef<string>, c), 'nominal', c);\n      }\n    });\n  });\n\n  describe('normalize()', () => {\n    it('should convert primitive type to value def', log.wrap((localLogger) => {\n      assert.deepEqual<ChannelDef<string>>(normalize(5 as any, 'x'), {value: 5});\n      assert.equal(localLogger.warns.length, 1);\n    }));\n\n    it('should return fieldDef with full type name.', () => {\n      const fieldDef: FieldDef<string> = {field: 'a', type: 'q' as any};\n      assert.deepEqual<ChannelDef<string>>(normalize(fieldDef, 'x'), {field: 'a', type: 'quantitative'});\n    });\n\n    it('normalizes yearmonthday to become yearmonthdate.', log.wrap((localLogger) => {\n      const fieldDef: FieldDef<string> = {\n        timeUnit: 'yearmonthday' as TimeUnit,  // Need to cast here as this is intentionally wrong\n        field: 'a',\n        type: 'temporal'\n      };\n      assert.deepEqual<ChannelDef<string>>(normalize(fieldDef, 'x'), {timeUnit: 'yearmonthdate', field: 'a', type: 'temporal'});\n      assert.equal(localLogger.warns[0], log.message.dayReplacedWithDate('yearmonthday'));\n    }));\n\n    it('should replace other type with quantitative for a field with counting aggregate.', log.wrap((localLogger) => {\n      for (const aggregate of COUNTING_OPS) {\n        const fieldDef: FieldDef<string> = {aggregate, field: 'a', type: 'nominal'};\n        assert.deepEqual<ChannelDef<string>>(normalize(fieldDef, 'x'), {aggregate, field: 'a', type: 'quantitative'});\n      }\n      assert.equal(localLogger.warns.length, 4);\n    }));\n\n    it('should return fieldDef with default type and throw warning if type is missing.', log.wrap((localLogger) => {\n      const fieldDef = {field: 'a'} as FieldDef<string>;\n      assert.deepEqual<ChannelDef<string>>(normalize(fieldDef, 'x'), {field: 'a', type: 'quantitative'});\n      assert.equal(localLogger.warns[0], log.message.emptyOrInvalidFieldType(undefined, 'x', 'quantitative'));\n    }));\n\n    it('should drop invalid aggregate ops and throw warning.', log.wrap((localLogger) => {\n      const fieldDef: FieldDef<string> = {aggregate: 'box-plot', field: 'a', type: 'quantitative'};\n      assert.deepEqual<ChannelDef<string>>(normalize(fieldDef, 'x'), {field: 'a', type: 'quantitative'});\n      assert.equal(localLogger.warns[0], log.message.invalidAggregate('box-plot'));\n    }));\n  });\n\n  describe('channelCompatability', () => {\n    describe('row/column', () => {\n      it('is incompatible with continuous field', () => {\n        for (const channel of ['row', 'column'] as Channel[]) {\n          assert(!channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible);\n        }\n      });\n      it('is compatible with discrete field', () => {\n        for (const channel of ['row', 'column'] as Channel[]) {\n          assert(channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible);\n        }\n      });\n    });\n\n    describe('x/y/color/text/detail', () => {\n      it('is compatible with continuous field', () => {\n        for (const channel of ['x', 'y', 'color', 'text', 'detail'] as Channel[]) {\n          assert(channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible);\n        }\n      });\n      it('is compatible with discrete field', () => {\n        for (const channel of ['x', 'y', 'color', 'text', 'detail'] as Channel[]) {\n          assert(channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible);\n        }\n      });\n    });\n\n    describe('opacity/size/x2/y2', () => {\n      it('is compatible with continuous field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          assert(channelCompatibility({field: 'a', type: 'quantitative'}, channel).compatible);\n        }\n      });\n\n      it('is compatible with binned field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          assert(channelCompatibility({bin: true, field: 'a', type: 'quantitative'}, channel).compatible);\n        }\n      });\n\n      it('is incompatible with nominal field', () => {\n        for (const channel of ['opacity', 'size', 'x2', 'y2'] as Channel[]) {\n          assert(!channelCompatibility({field: 'a', type: 'nominal'}, channel).compatible);\n        }\n      });\n    });\n\n    describe('shape', () => {\n      it('is compatible with nominal field', () => {\n        assert(channelCompatibility({field: 'a', type: 'nominal'}, 'shape').compatible);\n      });\n      it('is incompatible with ordinal field', () => {\n        assert(!channelCompatibility({field: 'a', type: 'ordinal'}, 'shape').compatible);\n      });\n      it('is incompatible with quantitative field', () => {\n        assert(!channelCompatibility({field: 'a', type: 'quantitative'}, 'shape').compatible);\n      });\n    });\n\n    describe('order', () => {\n      it('is incompatible with nominal field', () => {\n        assert(!channelCompatibility({field: 'a', type: 'nominal'}, 'order').compatible);\n      });\n      it('is compatible with ordinal field', () => {\n        assert(channelCompatibility({field: 'a', type: 'ordinal'}, 'order').compatible);\n      });\n      it('is compatible with quantitative field', () => {\n        assert(channelCompatibility({field: 'a', type: 'quantitative'}, 'order').compatible);\n      });\n    });\n  });\n\n  describe('title()', () => {\n    it('should return correct title for aggregate', () => {\n      assert.equal(title({field: 'f', aggregate: 'mean'}, {}), 'Mean of f');\n    });\n\n    it('should return correct title for count', () => {\n      assert.equal(title({aggregate: 'count'}, {countTitle: 'baz!'}), 'baz!');\n    });\n\n    it('should return correct title for bin', () => {\n      const fieldDef = {field: 'f', type: QUANTITATIVE, bin: true};\n      assert.equal(title(fieldDef,{}), 'f (binned)');\n    });\n\n    it('should return correct title for bin', () => {\n      const fieldDef = {field: 'f', type: QUANTITATIVE, bin: true};\n      assert.equal(title(fieldDef,{fieldTitle: 'functional'}), 'BIN(f)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.MONTH};\n      assert.equal(title(fieldDef,{}), 'f (month)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.YEARMONTHDATE};\n      assert.equal(title(fieldDef,{}), 'f (year-month-date)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.DAY};\n      assert.equal(title(fieldDef,{}), 'f (day)');\n    });\n\n    it('should return correct title for timeUnit', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL, timeUnit: TimeUnit.YEARQUARTER};\n      assert.equal(title(fieldDef,{}), 'f (year-quarter)');\n    });\n\n    it('should return correct title for raw field', () => {\n      const fieldDef = {field: 'f', type: TEMPORAL};\n      assert.equal(title(fieldDef,{}), 'f');\n    });\n  });\n});\n"]}