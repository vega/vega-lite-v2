{"version":3,"file":"parse.test.js","sourceRoot":"","sources":["../../../../test/compile/legend/parse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {COLOR, OPACITY, SHAPE, SIZE} from '../../../src/channel';\nimport * as legendParse from '../../../src/compile/legend/parse';\nimport {parseLegend} from '../../../src/compile/legend/parse';\nimport {isFieldDef} from '../../../src/fielddef';\nimport {NormalizedUnitSpec} from '../../../src/spec';\nimport {GEOJSON} from '../../../src/type';\nimport {parseLayerModel, parseUnitModelWithScale} from '../../util';\n\ndescribe('compile/legend', function () {\n  describe('parseUnitLegend()', function () {\n    it(`should not produce a Vega legend object on channel 'shape' with type 'geojson'`, function () {\n      const spec: NormalizedUnitSpec = {\n        \"mark\": \"geoshape\",\n        \"data\": {\"url\": \"data/income.json\"},\n        \"transform\": [\n          {\n            \"lookup\": \"id\",\n            \"from\": {\n              \"data\": {\n                \"url\": \"data/us-10m.json\",\n                \"format\": {\"type\": \"topojson\", \"feature\": \"states\"}\n              },\n              \"key\": \"id\"\n            },\n            \"as\": \"geo\"\n          }\n        ],\n        \"encoding\": {\n          \"shape\": {\"field\": \"geo\", \"type\": \"geojson\"}\n        }\n      };\n\n      const unitModel = parseUnitModelWithScale(spec);\n      const channelDef = unitModel.encoding[SHAPE];\n      assert.isTrue(isFieldDef(channelDef));\n      if (isFieldDef(channelDef)) {\n        assert.equal(channelDef.type, GEOJSON);\n      }\n      parseLegend(unitModel);\n      const legendComp = unitModel.component.legends;\n      assert.isUndefined(legendComp[SHAPE]);\n    });\n  });\n\n  describe('parseLegendForChannel()', function() {\n    it('should produce a Vega legend object with correct type and scale for color', function() {\n      const model = parseUnitModelWithScale({\n        mark: \"point\",\n        encoding: {\n          x: {field: \"a\", type: \"nominal\"},\n          color: {field: \"a\", type: \"quantitative\"}\n        }\n      });\n\n      const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n      assert.isObject(def);\n      assert.equal(def.title, 'a');\n      assert.equal(def.stroke, 'color');\n      assert.equal(def.type, 'gradient');\n    });\n\n    it('should produce no legend title when title is null, \"\", or false', function () {\n      for (const val of [null, '', false]) {\n        const model = parseUnitModelWithScale({\n          mark: \"point\",\n          encoding: {\n            x: {field: \"a\", type: \"nominal\"},\n            color: {\n              field: \"a\", type: \"quantitative\",\n              legend: {title: val as any} // Need to cast as false is not valid, but we want to fall back gracefully\n            }\n          }\n        });\n\n        const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n        assert.doesNotHaveAnyKeys(def, ['title']);\n      }\n    });\n\n\n    it('should store fieldDef.title as explicit', function () {\n      const model = parseUnitModelWithScale({\n        mark: \"point\",\n        encoding: {\n          x: {field: \"a\", type: \"nominal\"},\n          color: {\n            field: \"a\", type: \"quantitative\",\n            legend: {title: 'foo'} // Need to cast as false is not valid, but we want to fall back gracefully\n          }\n        }\n      });\n\n      const def = legendParse.parseLegendForChannel(model, COLOR).combine();\n      assert.equal(def.title, 'foo');\n    });\n\n    [SIZE, SHAPE, OPACITY].forEach(channel => {\n      it(`should produce a Vega legend object with correct type and scale for ${channel}`, function() {\n        const spec: NormalizedUnitSpec = {\n          mark: \"point\",\n          encoding: {\n            x: {field: \"a\", type: \"nominal\"}\n          }\n        };\n        spec.encoding[channel] = {field: \"a\", type: \"nominal\"};\n\n        const model = parseUnitModelWithScale(spec);\n\n        const def = legendParse.parseLegendForChannel(model, channel).combine();\n\n        const channelDef = model.encoding[channel];\n        if (isFieldDef(channelDef)) {\n          assert.notEqual(channelDef.type, GEOJSON);\n        }\n\n        if (channel !== OPACITY) {\n          assert.equal(def.encode.symbols.update.opacity.value, 0.7);\n        } else {\n          assert.isUndefined(def.encode.symbols.update.opacity);\n        }\n        assert.isObject(def);\n        assert.equal(def.title, \"a\");\n      });\n    });\n  });\n\n  describe('parseNonUnitLegend()', () => {\n    it('should correctly merge orient by favoring explicit orient', () => {\n      const model = parseLayerModel({\n        \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n        \"description\": \"Google's stock price over time.\",\n        \"data\": {\"url\": \"data/stocks.csv\"},\n        \"layer\": [\n          {\n            \"mark\": \"line\",\n            \"encoding\": {\n              \"x\": {\"field\": \"date\", \"type\": \"temporal\"},\n              \"y\": {\"field\": \"price\", \"type\": \"quantitative\"},\n              \"color\": {\"field\": \"symbol\", \"type\": \"nominal\"}\n            }\n          },{\n            \"mark\": {\"type\":\"point\", \"filled\": true},\n            \"encoding\": {\n              \"x\": {\"field\": \"date\", \"type\": \"temporal\"},\n              \"y\": {\"field\": \"price\", \"type\": \"quantitative\"},\n              \"color\": {\"field\": \"symbol\", \"type\": \"nominal\", \"legend\": {\"orient\": \"left\"}}\n            }\n          }\n        ]\n      });\n      model.parseScale();\n      model.parseLegend();\n      assert.equal(model.component.legends.color.explicit.orient, 'left');\n    });\n\n    it('should correctly merge legend that exists only on one plot', () => {\n      const model = parseLayerModel({\n        \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n        \"description\": \"Google's stock price over time.\",\n        \"data\": {\"url\": \"data/stocks.csv\"},\n        \"layer\": [\n          {\n            \"mark\": \"line\",\n            \"encoding\": {\n              \"x\": {\"field\": \"date\", \"type\": \"temporal\"},\n              \"y\": {\"field\": \"price\", \"type\": \"quantitative\"}\n            }\n          },{\n            \"mark\": {\"type\":\"point\", \"filled\": true},\n            \"encoding\": {\n              \"x\": {\"field\": \"date\", \"type\": \"temporal\"},\n              \"y\": {\"field\": \"price\", \"type\": \"quantitative\"},\n              \"color\": {\"field\": \"symbol\", \"type\": \"nominal\"}\n            }\n          }\n        ]\n      });\n      model.parseScale();\n      model.parseLegend();\n      assert.isOk(model.component.legends.color);\n      assert.isUndefined(model.children[0].component.legends.color);\n      assert.isUndefined(model.children[1].component.legends.color);\n    });\n  });\n});\n"]}