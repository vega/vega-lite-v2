{"version":3,"file":"model.test.js","sourceRoot":"","sources":["../../../test/compile/model.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {NameMap} from '../../src/compile/model';\nimport {parseFacetModel, parseFacetModelWithScale} from '../util';\n\ndescribe('Model', () => {\n  describe('NameMap', function () {\n    it('should rename correctly', function () {\n      const map = new NameMap();\n      assert.equal(map.get('a'), 'a');\n\n      map.rename('a', 'b');\n      assert.equal(map.get('a'), 'b');\n      assert.equal(map.get('b'), 'b');\n\n      map.rename('b', 'c');\n      assert.equal(map.get('a'), 'c');\n      assert.equal(map.get('b'), 'c');\n      assert.equal(map.get('c'), 'c');\n\n      map.rename('z', 'a');\n      assert.equal(map.get('a'), 'c');\n      assert.equal(map.get('b'), 'c');\n      assert.equal(map.get('c'), 'c');\n      assert.equal(map.get('z'), 'c');\n    });\n  });\n\n  describe('hasDescendantWithFieldOnChannel', () => {\n    it('should return true if a child plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      assert(model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return true if a descendant plot has x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [{\n            mark: 'point',\n            encoding: {\n              x: {field: 'x', type: 'quantitative'}\n            }\n          },{\n            mark: 'point',\n            encoding: {\n              color: {field: 'x', type: 'quantitative'}\n            }\n          },]\n        }\n      });\n      assert(model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          mark: 'point',\n          encoding: {\n            color: {field: 'x', type: 'quantitative'}\n          }\n        }\n      });\n      assert(!model.hasDescendantWithFieldOnChannel('x'));\n    });\n\n    it('should return false if no descendant plot has a field on x', () => {\n      const model = parseFacetModel({\n        facet: {row: {field: 'a', type: 'nominal'}},\n        spec: {\n          layer: [{\n            mark: 'point',\n            encoding: {\n              color: {field: 'x', type: 'quantitative'}\n            }\n          },{\n            mark: 'point',\n            encoding: {\n              color: {field: 'x', type: 'quantitative'}\n            }\n          },]\n        }\n      });\n      assert(!model.hasDescendantWithFieldOnChannel('x'));\n    });\n  });\n\n  describe('getSizeSignalRef', () => {\n    it('returns formula for step if parent is facet', () => {\n      const model = parseFacetModelWithScale({\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'b', type: 'nominal', scale: {\n              padding: 0.345\n            }}\n          }\n        },\n        resolve: {\n          scale: {x: 'independent'}\n        }\n      });\n\n      assert.deepEqual(model.child.getSizeSignalRef('width'), {\n        signal: `bandspace(datum[\\\"distinct_b\\\"], 1, 0.345) * child_x_step`\n      });\n    });\n  });\n});\n"]}