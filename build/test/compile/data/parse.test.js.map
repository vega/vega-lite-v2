{"version":3,"file":"parse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/parse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {AncestorParse} from '../../../src/compile/data';\nimport {AggregateNode} from '../../../src/compile/data/aggregate';\nimport {BinNode} from '../../../src/compile/data/bin';\nimport {CalculateNode} from '../../../src/compile/data/calculate';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {FilterNode} from '../../../src/compile/data/filter';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {parseTransformArray} from '../../../src/compile/data/parse';\nimport {TimeUnitNode} from '../../../src/compile/data/timeunit';\nimport {WindowTransformNode} from '../../../src/compile/data/window';\nimport {Transform} from '../../../src/transform';\nimport {parseUnitModel} from '../../util';\n\ndescribe('compile/data/parse', () => {\n  describe('parseTransformArray()', () => {\n    it('should return a CalculateNode and a FilterNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{calculate: 'calculate', as: 'as'}, {filter: 'filter'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof CalculateNode);\n      assert.isTrue(result instanceof FilterNode);\n    });\n\n    it('should add a parse node for filter transforms with time unit', () => {\n      const model = parseUnitModel({\n        \"data\": {\"url\": \"a.json\"},\n        \"transform\": [{\n          \"filter\": {\n            \"not\": {\n              \"and\": [{\n                \"or\": [\n                  {\n                    \"timeUnit\": \"year\",\n                    \"field\": \"date\",\n                    \"equal\": 2005\n                  },\n                  \"datum.a > 5\"\n                ]\n              }]\n            }\n          }\n        }],\n        \"mark\": \"point\",\n        \"encoding\": {\n          \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n          \"y\": {\"field\": \"b\", \"type\": \"temporal\"},\n          \"color\": {\"field\": \"c\", \"type\": \"ordinal\"},\n          \"shape\": {\"field\": \"d\", \"type\": \"nominal\"}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n\n      assert.isTrue(root.children[0] instanceof ParseNode);\n      assert.isTrue(result instanceof FilterNode);\n      assert.deepEqual((root.children[0] as ParseNode).parse, {\n        date: 'date'\n      });\n      assert.deepEqual(parse.combine(), {date: 'date'});\n    });\n\n    it('should return a BinNode node and a TimeUnitNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{bin: true, field: 'field', as: 'a'}, {timeUnit: 'month', field: 'field', as: 'b'}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const parse = new AncestorParse();\n      const result = parseTransformArray(root, model, parse);\n      assert.isTrue(root.children[0] instanceof BinNode);\n      assert.isTrue(result instanceof TimeUnitNode);\n      assert.deepEqual(parse.combine(), {a: 'number', a_end: 'number', b: 'date'});\n    });\n\n    it('should return a BinNode and a AggregateNode', () => {\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [{bin: true, field: 'field', as: 'a'}, {aggregate: [{op: 'count', field: 'f', as: 'b'}, {op: 'sum', field: 'f', as: 'c'}], groupby: ['field']}],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n\n      const root = new DataFlowNode(null);\n      const result = parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof BinNode);\n      assert.isTrue(result instanceof AggregateNode);\n    });\n\n    it ('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b',\n          }\n        ],\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          transform\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n    it ('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number',\n          },\n        ],\n        ignorePeers: false,\n        sort:  [\n          {\n            field:'f',\n            order:'ascending'\n          }\n        ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          transform\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n\n    it ('should return a WindowTransform Node', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'count',\n            field: 'f',\n            as: 'b',\n          }\n        ],\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          transform\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n    it ('should return a WindowTransform Node with optional properties', () => {\n      const transform: Transform = {\n        window: [\n          {\n            op: 'row_number',\n            as: 'ordered_row_number',\n          },\n        ],\n        ignorePeers: false,\n        sort: [\n            {\n              field:'f',\n              order:'ascending'\n            }\n          ]\n      };\n      const model = parseUnitModel({\n        data: {values: []},\n        mark: 'point',\n        transform: [\n          transform\n        ],\n        encoding: {\n          x: {field: 'a', type: 'temporal', timeUnit: 'month'}\n        }\n      });\n      const root = new DataFlowNode(null);\n      parseTransformArray(root, model, new AncestorParse());\n      assert.isTrue(root.children[0] instanceof WindowTransformNode);\n    });\n  });\n});\n"]}