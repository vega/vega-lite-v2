{"version":3,"file":"formatparse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/formatparse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\nimport {assert} from 'chai';\nimport {AncestorParse} from '../../../src/compile/data';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {parseTransformArray} from '../../../src/compile/data/parse';\nimport {ModelWithField} from '../../../src/compile/model';\nimport * as log from '../../../src/log';\nimport {parseFacetModel, parseUnitModel} from '../../util';\n\ndescribe('compile/data/formatparse', () => {\n  describe('parseUnit', () => {\n    it('should parse binned fields as numbers', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"encoding\": {\n          \"x\": {\"field\": \"a\", \"type\": \"ordinal\", \"bin\": true},\n          \"y\": {\"field\": \"b\", \"type\": \"ordinal\"}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse, {\n        a: 'number'\n      });\n    });\n\n    it('should flatten nested fields that are used to sort domains', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"encoding\": {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}},\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse, {\n        'foo.bar': 'flatten'\n      });\n    });\n\n    it('should return a correct customized parse.', () => {\n      const model = parseUnitModel({\n        \"data\": {\"url\": \"a.json\", \"format\": {\"parse\": {\"c\": \"number\", \"d\": \"date\"}}},\n        \"mark\": \"point\",\n        \"encoding\": {\n          \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n          \"y\": {\"field\": \"b\", \"type\": \"temporal\"},\n          \"color\": {\"field\": \"c\", \"type\": \"ordinal\"},\n          \"shape\": {\"field\": \"c\", \"type\": \"nominal\"}\n        }\n      });\n\n      const ancestorParese = new AncestorParse();\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, ancestorParese).parse, {\n        a: 'number',\n        b: 'date'\n      });\n\n      assert.deepEqual(ParseNode.makeExplicit(null, model, ancestorParese).parse, {\n        c: 'number',\n        d: 'date'\n      });\n    });\n\n    it('should include parse for all applicable fields, and exclude calculated fields', function() {\n      const model = parseUnitModel({\n        transform: [{calculate: 'datum[\"b\"] * 2', as: 'b2'}],\n        mark: \"point\",\n        encoding: {\n          x: {field: 'a', type: \"temporal\"},\n          y: {field: 'b', type: \"quantitative\"},\n          color: {type: \"quantitative\", aggregate: 'count'},\n          size: {field: 'b2', type: \"quantitative\"},\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      const parent = new DataFlowNode(null);\n      parseTransformArray(parent, model, ancestorParse);\n      assert.deepEqual(ancestorParse.combine(), {'b2': 'derived'});\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse).parse, {\n        'a': 'date',\n        'b': 'number'\n      });\n    });\n\n    it('should not parse fields with aggregate=missing/valid/distinct', function() {\n      const model = parseUnitModel({\n        mark: \"point\",\n        encoding: {\n          x: {aggregate: 'missing', field: 'b', type: \"quantitative\"},\n          y: {aggregate: 'valid', field: 'b', type: \"quantitative\"},\n          color: {aggregate: 'distinct', field: 'b', type: \"quantitative\"}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()), null);\n    });\n\n    it('should not parse the same field twice', function() {\n      const model = parseFacetModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: \"point\",\n          encoding: {\n            x: {field: 'a', type: \"quantitative\"},\n            y: {field: 'b', type: \"temporal\"}\n          }\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeExplicit(null, model, new AncestorParse()).parse, {\n        'a': 'number'\n      });\n      model.parseScale();\n      model.parseData();\n\n      assert.deepEqual(model.child.component.data.ancestorParse.combine(), {\n        'a': 'number',\n        'b': 'date'\n      });\n\n      // set the ancestor parse to see whether fields from it are not parsed\n      model.child.component.data.ancestorParse = new AncestorParse({a: 'number'});\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model.child as ModelWithField, model.child.component.data.ancestorParse).parse, {\n        'b': 'date'\n      });\n    });\n\n    it('should not parse the same field twice in explicit', function() {\n      const model = parseUnitModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        mark: \"point\",\n        encoding: {}\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {})));\n    });\n\n    it('should not parse the same field twice in implicit', function() {\n      const model = parseUnitModel({\n        mark: \"point\",\n        encoding: {\n          x: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {})));\n    });\n\n    it('should not parse counts', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"encoding\": {\n          \"x\": {\"aggregate\": \"sum\", \"field\": \"foo\", \"type\": \"quantitative\"},\n          \"y\": {\"aggregate\": \"count\", \"type\": \"quantitative\"}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse, {\n        \"foo\": \"number\"\n      });\n    });\n\n    it('should add flatten for nested fields', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"encoding\": {\n          \"x\": {\"field\": \"foo.bar\", \"type\": \"quantitative\"},\n          \"y\": {\"field\": \"foo.baz\", \"type\": \"ordinal\"}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse, {\n        \"foo.bar\": \"number\",\n        \"foo.baz\": \"flatten\"\n      });\n    });\n\n    it('should not parse if parse is disabled for a field', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"data\": {\n          \"values\": [],\n          \"format\": {\n            \"parse\": {\n              \"b\": null\n            }\n          }\n        },\n        \"encoding\": {\n          \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n          \"y\": {\"field\": \"b\", \"type\": \"quantitative\"}\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      assert.isNull(ParseNode.makeExplicit(null, model, ancestorParse), null);\n      assert.deepEqual(ancestorParse.combine(), {\n        b: null\n      });\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse).parse, {\n        a: 'number'\n      });\n    });\n\n    it('should not parse if parse is disabled', () => {\n      const model = parseUnitModel({\n        \"mark\": \"point\",\n        \"data\": {\n          \"values\": [],\n          \"format\": {\n            \"parse\": null  // implies AncestorParse.makeExplicit = true\n          }\n        },\n        \"encoding\": {\n          \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n          \"y\": {\"field\": \"b\", \"type\": \"quantitative\"}\n        }\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({}, {}, true)));\n    });\n  });\n\n  describe('assembleTransforms', function() {\n    it('should assemble correct parse expressions', function() {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        s: 'string',\n        d1: 'date',\n        d2: 'date:\"%y\"',\n        d3: 'utc:\"%y\"'\n      });\n\n      assert.deepEqual(p.assembleTransforms(), [\n        {type: 'formula', expr: 'toNumber(datum[\"n\"])', as: 'n'},\n        {type: 'formula', expr: 'toBoolean(datum[\"b\"])', as: 'b'},\n        {type: 'formula', expr: 'toString(datum[\"s\"])', as: 's'},\n        {type: 'formula', expr: 'toDate(datum[\"d1\"])', as: 'd1'},\n        {type: 'formula', expr: 'timeParse(datum[\"d2\"],\"%y\")', as: 'd2'},\n        {type: 'formula', expr: 'utcParse(datum[\"d3\"],\"%y\")', as: 'd3'}\n      ]);\n    });\n\n    it('should assemble flatten for nested fields', function() {\n      const p = new ParseNode(null, {\n        flat: 'number',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.assembleTransforms(true), [\n        {type: 'formula', expr: 'datum[\"nested\"] && datum[\"nested\"][\"field\"]', as: 'nested.field'}\n      ]);\n    });\n\n    it('should show warning for unrecognized types', log.wrap((localLogger) => {\n      const p = new ParseNode(null, {\n        x: 'foo',\n      });\n\n      assert.deepEqual(p.assembleTransforms(), []);\n      assert.equal(localLogger.warns[0], log.message.unrecognizedParse('foo'));\n    }));\n  });\n\n  describe('assembleFormatParse', function() {\n    it('should assemble correct parse', function() {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.assembleFormatParse(), {\n        n: 'number',\n        b: 'boolean'\n      });\n    });\n  });\n\n  describe('producedFields', function() {\n    it('should produce the correct fields', function() {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.producedFields(), {n: true, b: true, 'nested.field': true});\n    });\n  });\n});\n"]}