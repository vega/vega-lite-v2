{"version":3,"file":"domain.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/domain.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\nimport {ScaleChannel} from '../../../src/channel';\nimport {domainSort, mergeDomains, parseDomainForChannel} from '../../../src/compile/scale/domain';\nimport {parseScaleCore} from '../../../src/compile/scale/parse';\nimport {UnitModel} from '../../../src/compile/unit';\nimport {MAIN} from '../../../src/data';\nimport {PositionFieldDef} from '../../../src/fielddef';\nimport * as log from '../../../src/log';\nimport {ScaleType} from '../../../src/scale';\nimport {EncodingSortField} from '../../../src/sort';\nimport {VgDomain, VgSortField} from '../../../src/vega.schema';\nimport {parseUnitModel} from '../../util';\n\ndescribe('compile/scale', () => {\n  describe('parseDomainForChannel()', () => {\n    function testParseDomainForChannel(model: UnitModel, channel: ScaleChannel) {\n      // Cannot parseDomain before parseScaleCore\n      parseScaleCore(model);\n      return parseDomainForChannel(model, channel);\n    }\n\n    it('should have correct domain with x and x2 channel', function() {\n      const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {field: 'a', type: 'quantitative'},\n            x2: {field: 'b', type: 'quantitative'},\n            y: {field: 'c', type: 'quantitative'},\n            y2: {field: 'd', type: 'quantitative'}\n          }\n        });\n\n      const xDomain = testParseDomainForChannel(model, 'x');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}, {data: 'main', field: 'b'}]);\n\n      const yDomain = testParseDomainForChannel(model, 'y');\n      assert.deepEqual(yDomain, [{data: 'main', field: 'c'}, {data: 'main', field: 'd'}]);\n    });\n\n    it('should have correct domain for color', function() {\n      const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            color: {field: 'a', type: 'quantitative'},\n          }\n        });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}]);\n    });\n\n    it('should have correct domain for color ConditionField', function() {\n      const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            color: {\n              condition: {selection: 'sel', field: 'a', type: 'quantitative'}\n            }\n          }\n        });\n\n      const xDomain = testParseDomainForChannel(model, 'color');\n      assert.deepEqual(xDomain, [{data: 'main', field: 'a'}]);\n    });\n\n    it('should return domain for stack', function() {\n      const model = parseUnitModel({\n        mark: \"bar\",\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: \"ordinal\"},\n          color: {field: 'color', type: \"ordinal\"}\n        }\n      });\n\n      assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n        data: 'main',\n        field: 'sum_origin_start'\n      }, {\n        data: 'main',\n        field: 'sum_origin_end'\n      }]);\n    });\n\n    it('should return normalize domain for stack if specified', function() {\n      const model = parseUnitModel({\n        mark: \"bar\",\n        encoding: {\n          y: {\n            aggregate: 'sum',\n            field: 'origin',\n            type: 'quantitative'\n          },\n          x: {field: 'x', type: \"ordinal\"},\n          color: {field: 'color', type: \"ordinal\"}\n        },\n        config: {\n          stack: \"normalize\"\n        }\n      });\n\n      assert.deepEqual(testParseDomainForChannel(model,'y'), [[0, 1]]);\n    });\n\n    describe('for quantitative', function() {\n      it('should return the right domain for binned Q', log.wrap((localLogger) => {\n        const fieldDef: PositionFieldDef<string> = {\n          bin: {maxbins: 15},\n          field: 'origin',\n          scale: {domain: 'unaggregated'},\n          type: 'quantitative'\n        };\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: fieldDef\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n            data: 'main',\n            field: 'bin_maxbins_15_origin'\n          }, {\n            data: 'main',\n            field: 'bin_maxbins_15_origin_end'\n          }]);\n\n        assert.equal(localLogger.warns[0], log.message.unaggregateDomainHasNoEffectForRawField(fieldDef));\n      }));\n\n      it('should follow the custom bin.extent for binned Q', log.wrap((localLogger) => {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'quantitative',\n              bin: {maxbins: 15, extent:[0, 100]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model,'y');\n\n        assert.deepEqual(_domain, [[0, 100]]);\n      }));\n\n      it('should return the unaggregated domain if requested for non-bin, non-sum Q',\n        function() {\n          const model = parseUnitModel({\n            mark: \"point\",\n            encoding: {\n              y: {\n                aggregate: 'mean',\n                field: 'acceleration',\n                scale: {domain: 'unaggregated'},\n                type: \"quantitative\"\n              }\n            }\n          });\n\n          assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n            data: MAIN,\n            field: 'min_acceleration'\n          }, {\n            data: MAIN,\n            field: 'max_acceleration'\n          }]);\n        });\n\n      it('should return the aggregated domain for sum Q', log.wrap((localLogger) => {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              aggregate: 'sum',\n              field: 'origin',\n              scale: {domain: 'unaggregated'},\n              type: \"quantitative\"\n            }\n          }\n        });\n        testParseDomainForChannel(model,'y');\n        assert.equal(\n          localLogger.warns[0], log.message.unaggregateDomainWithNonSharedDomainOp('sum')\n        );\n      }));\n\n      it('should return the right custom domain', () => {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              field: 'horsepower',\n              type: \"quantitative\",\n              scale: {domain: [0,200]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model,'y');\n\n        assert.deepEqual(_domain, [[0, 200]]);\n      });\n\n      it('should follow the custom domain despite bin', log.wrap((localLogger) => {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              field: 'origin',\n              type: 'quantitative',\n              scale: {domain: [0,200]},\n              bin: {maxbins: 15}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model,'y');\n\n        assert.deepEqual(_domain, [[0, 200]]);\n      }));\n\n      it('should return the aggregated domain if we do not override it', function() {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'origin',\n              type: \"quantitative\"\n            }\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [\n          {\n            data: 'main',\n            field: 'min_origin'\n          }\n        ]);\n      });\n\n      it('should use the aggregated data for domain if specified in config', function() {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              aggregate: 'min',\n              field: 'acceleration',\n              type: \"quantitative\"\n            }\n          },\n          config: {\n            scale: {\n              useUnaggregatedDomain: true\n            }\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n            data: MAIN,\n            field: 'min_acceleration'\n          }, {\n            data: MAIN,\n            field: 'max_acceleration'\n          }]);\n      });\n    });\n\n    describe('for time', function() {\n      it('should return the correct domain for month T',\n        function() {\n          const model = parseUnitModel({\n            mark: \"point\",\n            encoding: {\n              y: {\n                field: 'origin',\n                type: \"temporal\",\n                timeUnit: 'month'\n              }\n            }\n          });\n          const _domain = testParseDomainForChannel(model,'y');\n          assert.deepEqual(_domain, [{data: 'main', field: 'month_origin'}]);\n        });\n\n        it('should return the correct domain for month O',\n          function() {\n            const model = parseUnitModel({\n              mark: \"point\",\n              encoding: {\n                y: {\n                  field: 'origin',\n                  type: \"ordinal\",\n                  timeUnit: 'month'\n                }\n              }\n            });\n            const _domain = testParseDomainForChannel(model,'y');\n            assert.deepEqual(_domain, [{data: 'main', field: 'month_origin', sort: true}]);\n          });\n\n        it('should return the correct domain for yearmonth T',\n          function() {\n            const model = parseUnitModel({\n              mark: \"point\",\n              encoding: {\n                y: {\n                  field: 'origin',\n                  type: \"temporal\",\n                  timeUnit: 'yearmonth'\n                }\n              }\n            });\n            const _domain = testParseDomainForChannel(model,'y');\n\n            assert.deepEqual(_domain, [{data: 'main', field: 'yearmonth_origin'}]);\n          });\n\n\n        it('should return the correct domain for month O when specify sort',\n          function() {\n            const sortDef: EncodingSortField<string> = {op: 'mean', field: 'precipitation', order: 'descending'} ;\n            const model = parseUnitModel({\n              mark: \"bar\",\n              encoding: {\n                x: {\n                  timeUnit: 'month',\n                  field: 'date',\n                  type: 'ordinal',\n                  sort: sortDef\n                },\n                y: {\n                  aggregate: 'mean',\n                  field: 'precipitation',\n                  type: 'quantitative'\n                }\n              }\n            });\n            const _domain = testParseDomainForChannel(model,'x');\n\n            assert.deepEqual(_domain, [{\n              data: 'raw',\n              field: 'month_date',\n              sort: sortDef\n            }]);\n        });\n\n      it('should return the right custom domain with DateTime objects', () => {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {\n              field: 'year',\n              type: \"temporal\",\n              scale: {domain: [{year: 1970}, {year: 1980}]}\n            }\n          }\n        });\n        const _domain = testParseDomainForChannel(model, 'y');\n\n        expect(_domain).toEqual([\n          {\"signal\": \"{data: datetime(1970, 0, 1, 0, 0, 0, 0)}\"},\n          {\"signal\": \"{data: datetime(1980, 0, 1, 0, 0, 0, 0)}\"}\n        ]);\n      });\n\n    it('should return the right custom domain with date strings', () => {\n      const model = parseUnitModel({\n        mark: \"point\",\n        encoding: {\n          y: {\n            field: 'year',\n            type: \"temporal\",\n            scale: {domain: [\"Jan 1, 2007\", \"Jan 1, 2009\"]}\n          }\n        }\n      });\n      const _domain = testParseDomainForChannel(model, 'y');\n\n      expect(_domain).toEqual([\n        {\"signal\": `{data: datetime(\"Jan 1, 2007\")}`},\n        {\"signal\": `{data: datetime(\"Jan 1, 2009\")}`},\n      ]);\n    });\n  });\n\n    describe('for ordinal', function() {\n      it('should have correct domain for binned ordinal color', function() {\n        const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            color: {field: 'a', bin: true, type: 'ordinal'},\n          }\n        });\n\n        const xDomain = testParseDomainForChannel(model, 'color');\n        assert.deepEqual(xDomain, [{data: 'main', field: 'bin_maxbins_6_a_range', sort: {field: 'bin_maxbins_6_a', op: 'min'}}]);\n      });\n    });\n\n    describe('for nominal', function() {\n      it('should return correct domain with the provided sort property', function() {\n        const sortDef: EncodingSortField<string> = {op: 'min' as 'min', field:'Acceleration'};\n        const model = parseUnitModel({\n            mark: \"point\",\n            encoding: {\n              y: {field: 'origin', type: \"nominal\", sort: sortDef}\n            }\n          });\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n            data: \"raw\",\n            field: 'origin',\n            sort: sortDef\n          }]);\n      });\n\n      it('should return correct domain with the provided sort property with order property', function() {\n        const sortDef: EncodingSortField<string> = {op: 'min', field:'Acceleration', order: \"descending\"} ;\n        const model = parseUnitModel({\n            mark: \"point\",\n            encoding: {\n              y: {field: 'origin', type: \"nominal\", sort: sortDef}\n            }\n          });\n\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n            data: \"raw\",\n            field: 'origin',\n            sort: sortDef\n        }]);\n      });\n\n      it('should return correct domain without sort if sort is not provided', function() {\n        const model = parseUnitModel({\n          mark: \"point\",\n          encoding: {\n            y: {field: 'origin', type: \"nominal\"}\n          }\n        });\n\n        assert.deepEqual(testParseDomainForChannel(model,'y'), [{\n          data: \"main\",\n          field: 'origin',\n          sort: true\n        }]);\n      });\n    });\n  });\n\n  describe('mergeDomains()', () => {\n    it('should merge the same domains', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      }, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should drop field if op is count', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {op: 'count', field: 'b'}\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {op: 'count'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a'\n      }, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean', order: 'descending'}\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean', order: 'descending'}\n      });\n    });\n\n    it('should sort the output domain if one domain is sorted with true', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: true\n      }, {\n        data: 'foo',\n        field: 'b',\n      }]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b'],\n        sort: true\n      });\n    });\n\n    it('should not sort if no domain is sorted', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a'\n      }, {\n        data: 'foo',\n        field: 'b',\n      }]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should ignore order ascending as it is the default', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean', order: 'ascending'}\n      }, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: {field: 'b', op: 'mean'}\n      });\n    });\n\n    it('should merge domains with the same data', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a'\n      }, {\n        data: 'foo',\n        field: 'a'\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        field: 'a'\n      });\n    });\n\n    it('should merge domains with the same data source', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a'\n      }, {\n        data: 'foo',\n        field: 'b'\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        data: 'foo',\n        fields: ['a', 'b']\n      });\n    });\n\n    it('should merge domains with different data source', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: true\n      }, {\n        data: 'bar',\n        field: 'a',\n        sort: true\n      }]);\n\n      assert.deepEqual(domain, {\n        fields: [{\n          data: 'foo',\n          field: 'a'\n        }, {\n          data: 'bar',\n          field: 'a'\n        }],\n        sort: true\n      });\n    });\n\n    it('should merge domains with different data and sort', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {\n          op: 'count'\n        }\n      }, {\n        data: 'bar',\n        field: 'a'\n      }]);\n\n      assert.deepEqual<VgDomain>(domain, {\n        fields: [{\n          data: 'foo',\n          field: 'a'\n        }, {\n          data: 'bar',\n          field: 'a'\n        }],\n        sort: {\n          op: 'count'\n        }\n      });\n    });\n\n    it('should merge domains with the same and different data', () => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a'\n      }, {\n        data: 'foo',\n        field: 'b'\n      }, {\n        data: 'bar',\n        field: 'a'\n      }]);\n\n      assert.deepEqual(domain, {\n        fields: [{\n          data: 'foo',\n          field: 'a'\n        }, {\n          data: 'foo',\n          field: 'b'\n        }, {\n          data: 'bar',\n          field: 'a'\n        }]\n      });\n    });\n\n    it('should merge signal domains', () => {\n      const domain = mergeDomains([{\n        signal: 'foo'\n      }, {\n        data: 'bar',\n        field: 'a'\n      }]);\n\n      assert.deepEqual(domain, {\n        fields: [{\n            signal: 'foo'\n          }, {\n            data: 'bar',\n            field: 'a'\n          }\n        ]\n      });\n    });\n\n    it('should warn if sorts conflict', log.wrap((localLogger) => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {\n          op: 'count'\n        }\n      }, {\n        data: 'foo',\n        field: 'b',\n        sort: true\n      }]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b'],\n        sort: true\n      });\n\n      assert.equal(localLogger.warns[0], log.message.MORE_THAN_ONE_SORT);\n    }));\n\n    it('should warn if sorts conflict even if we do not union', log.wrap((localLogger) => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {\n          op: 'count'\n        }\n      }, {\n        data: 'foo',\n        field: 'a',\n        sort: true\n      }]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        field: 'a',\n        sort: true\n      });\n\n      assert.equal(localLogger.warns[0], log.message.MORE_THAN_ONE_SORT);\n    }));\n\n    it('should warn if we had to drop complex sort', log.wrap((localLogger) => {\n      const domain = mergeDomains([{\n        data: 'foo',\n        field: 'a',\n        sort: {\n          op: 'mean',\n          field: 'c'\n        }\n      }, {\n        data: 'foo',\n        field: 'b'\n      }]);\n\n      assert.deepEqual(domain, {\n        data: 'foo',\n        fields: ['a', 'b'],\n        sort: true\n      });\n\n      assert.equal(localLogger.warns[0], log.message.domainSortDropped({\n        op: 'mean',\n        field: 'c'\n      }));\n    }));\n\n    it('should not sort explicit domains', () => {\n      const domain = mergeDomains([[1,2,3,4], [3,4,5,6]]);\n\n      assert.deepEqual(domain, {\n        fields: [[1,2,3,4], [3,4,5,6]]\n      });\n    });\n  });\n\n  describe('domainSort()', () => {\n    it('should return undefined for continuous domain', () => {\n      const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'quantitative'},\n          }\n        });\n      const sort = domainSort(model, 'x', ScaleType.LINEAR);\n      assert.deepEqual(sort, undefined);\n    });\n\n    it('should return true by default for discrete domain', () => {\n      const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'ordinal'},\n          }\n        });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return true for ascending', () => {\n      const model = parseUnitModel({\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'quantitative', sort: 'ascending'},\n          }\n        });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return undefined if sort = null', () => {\n      const model = parseUnitModel({\n          mark: 'bar',\n          encoding: {\n            x: {field: 'a', type: 'quantitative', sort: null},\n          }\n        });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, undefined);\n    });\n\n    it('should return normal sort spec if specified and aggregration is not count', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'sum', field:'y'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual<VgSortField>(sort, {op: 'sum', field: 'y'});\n    });\n\n    it('should return normal sort spec if aggregration is count and field not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: {op: 'count'}},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual<VgSortField>(sort, {op: 'count'});\n    });\n\n    it('should return true if sort is not specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal'},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      const sort = domainSort(model, 'x', ScaleType.ORDINAL);\n      assert.deepEqual(sort, true);\n    });\n\n    it('should return undefined if sort is specified', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'nominal', sort: \"descending\"},\n          y: {field: 'b', aggregate: 'sum', type: 'quantitative'}\n        }\n      });\n      assert.deepEqual<VgSortField>(domainSort(model, 'x', ScaleType.ORDINAL), {op: 'min', field: 'a', order: 'descending'});\n    });\n\n    it('should return sort spec using derived sort index', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: ['B', 'A', 'C']},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n      assert.deepEqual<VgSortField>(domainSort(model, 'x', ScaleType.ORDINAL), {op: 'min', field: 'x_a_sort_index', order: 'ascending'});\n    });\n\n    it('should return sort with flattened field access', () => {\n      const model = parseUnitModel({\n        mark: 'bar',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}},\n        }\n      });\n      assert.deepEqual<VgSortField>(domainSort(model, 'x', ScaleType.ORDINAL), {op: 'mean', field: 'foo\\\\.bar'});\n    });\n  });\n});\n"]}