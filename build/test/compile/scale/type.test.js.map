{"version":3,"file":"type.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/type.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {assert} from 'chai';\nimport {rangeType, SCALE_CHANNELS, X, Y} from '../../../src/channel';\nimport {scaleType} from '../../../src/compile/scale/type';\nimport {defaultConfig} from '../../../src/config';\nimport * as log from '../../../src/log';\nimport {PRIMITIVE_MARKS} from '../../../src/mark';\nimport {ScaleType} from '../../../src/scale';\nimport {TIMEUNITS} from '../../../src/timeunit';\nimport {NOMINAL, ORDINAL} from '../../../src/type';\nimport * as util from '../../../src/util';\n\nconst defaultScaleConfig = defaultConfig.scale;\n\ndescribe('compile/scale', () => {\n  describe('type()', () => {\n    it('should return null for channel without scale', function() {\n      assert.deepEqual(\n        scaleType(undefined, 'detail', {type: 'temporal', timeUnit: 'yearmonth'}, 'point', defaultScaleConfig),\n        null\n      );\n    });\n\n    it('should show warning if users try to override the scale and use bin', log.wrap((localLogger) => {\n      assert.deepEqual(\n        scaleType('point', 'color', {type: 'quantitative', bin: true}, 'point', defaultScaleConfig),\n        ScaleType.BIN_ORDINAL\n      );\n      assert.equal(localLogger.warns[0], log.message.scaleTypeNotWorkWithFieldDef(ScaleType.POINT, ScaleType.BIN_ORDINAL));\n    }));\n\n    describe('nominal/ordinal', () => {\n      describe('color', () => {\n        it('should return ordinal scale for nominal data by default.', () => {\n          assert.equal(\n            scaleType(undefined, 'color', {type: 'nominal'}, 'point', defaultScaleConfig),\n            ScaleType.ORDINAL\n          );\n        });\n\n        it('should return ordinal scale for ordinal data.', () => {\n          assert.equal(\n            scaleType(undefined, 'color', {type: 'nominal'}, 'point', defaultScaleConfig),\n            ScaleType.ORDINAL\n          );\n        });\n      });\n\n      describe('discrete channel (shape)', () => {\n        it('should return ordinal for nominal field', function() {\n          assert.deepEqual(\n            scaleType(undefined, 'shape', {type: 'nominal'}, 'point', defaultScaleConfig),\n            ScaleType.ORDINAL\n          );\n        });\n\n        it('should return ordinal even if other type is specified', log.wrap((localLogger) => {\n          [ScaleType.LINEAR, ScaleType.BAND, ScaleType.POINT].forEach((badScaleType) => {\n            assert.deepEqual(\n              scaleType(badScaleType, 'shape', {type: 'nominal'}, 'point', defaultScaleConfig),\n              ScaleType.ORDINAL\n            );\n            const warns = localLogger.warns;\n            assert.equal(warns[warns.length-1], log.message.scaleTypeNotWorkWithChannel('shape', badScaleType, 'ordinal'));\n          });\n        }));\n\n        it('should return ordinal for an ordinal field and throw a warning.', log.wrap((localLogger) => {\n          assert.deepEqual(\n            scaleType(undefined, 'shape', {type: 'ordinal'}, 'point', defaultScaleConfig),\n            ScaleType.ORDINAL\n          );\n          assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'ordinal'));\n        }));\n      });\n\n      describe('continuous', () => {\n        it('should return point scale for ordinal X,Y for marks others than rect, rule, and bar', () => {\n          PRIMITIVE_MARKS.forEach((mark) => {\n            if (util.contains(['bar', 'rule', 'rect'], mark)) {\n              return;\n            }\n\n            [ORDINAL, NOMINAL].forEach((t) => {\n              [X, Y].forEach((channel) => {\n                assert.equal(\n                  scaleType(undefined, channel, {type: t}, mark, defaultScaleConfig),\n                  ScaleType.POINT\n                );\n              });\n            });\n          });\n        });\n\n        it('should return band scale for ordinal X,Y when mark is rect, rule, bar', () => {\n          [ORDINAL, NOMINAL].forEach((t) => {\n            [X, Y].forEach((channel) => {\n              ['bar', 'rule', 'rect'].forEach((mark) => {\n                assert.equal(\n                  scaleType(undefined, channel, {type: t}, 'rect', defaultScaleConfig),\n                  ScaleType.BAND\n                );\n              });\n            });\n          });\n        });\n\n        it('should return point scale for X,Y when mark is point', () => {\n          [ORDINAL, NOMINAL].forEach((t) => {\n            [X, Y].forEach((channel) => {\n              assert.equal(scaleType(undefined, channel, {type: t}, 'point', defaultScaleConfig), ScaleType.POINT);\n            });\n          });\n        });\n\n        it('should return point scale for X,Y when mark is point when ORDINAL SCALE TYPE is specified and throw warning', log.wrap((localLogger) => {\n          [ORDINAL, NOMINAL].forEach((t) => {\n            [X, Y].forEach((channel) => {\n              assert.equal(scaleType('ordinal', channel, {type: t}, 'point', defaultScaleConfig), ScaleType.POINT);\n              const warns = localLogger.warns;\n              assert.equal(warns[warns.length-1], log.message.scaleTypeNotWorkWithChannel(channel, 'ordinal', 'point'));\n            });\n          });\n        }));\n\n        it('should return point scale for ordinal/nominal fields for continuous channels other than x and y.', () => {\n          const OTHER_CONTINUOUS_CHANNELS = SCALE_CHANNELS.filter((c) => rangeType(c) === 'continuous' && !util.contains([X, Y], c));\n          PRIMITIVE_MARKS.forEach((mark) => {\n            [ORDINAL, NOMINAL].forEach((t) => {\n              OTHER_CONTINUOUS_CHANNELS.forEach((channel) => {\n                assert.equal(\n                  scaleType(undefined, channel, {type: t}, mark, defaultScaleConfig),\n                  ScaleType.POINT,\n                  `${channel}, ${mark}, ${t} ` + scaleType(undefined, channel, {type: t}, mark, defaultScaleConfig)\n                );\n              });\n            });\n          });\n        });\n      });\n    });\n\n    describe('temporal', () => {\n      it('should return sequential scale for temporal color field by default.', () => {\n        assert.equal(\n          scaleType(undefined, 'color', {type: 'temporal'}, 'point', defaultScaleConfig),\n          ScaleType.SEQUENTIAL\n        );\n      });\n\n      it('should return ordinal for temporal field and throw a warning.', log.wrap((localLogger) => {\n        assert.deepEqual(\n          scaleType(undefined, 'shape', {type: 'temporal', timeUnit: 'yearmonth'}, 'point', defaultScaleConfig),\n          ScaleType.ORDINAL\n        );\n        assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'temporal'));\n      }));\n\n      it('should return time for all time units.', function() {\n        for (const timeUnit of TIMEUNITS) {\n          assert.deepEqual(\n            scaleType(undefined, Y, {type: 'temporal', timeUnit: timeUnit}, 'point', defaultScaleConfig),\n            ScaleType.TIME\n          );\n        }\n      });\n    });\n    describe('quantitative', () => {\n      it('should return sequential scale for quantitative color field by default.', () => {\n        assert.equal(\n          scaleType(undefined, 'color', {type: 'quantitative'}, 'point', defaultScaleConfig),\n          ScaleType.SEQUENTIAL\n        );\n      });\n\n      it('should return ordinal bin scale for quantitative color field with binning.', () => {\n        assert.equal(\n          scaleType(undefined, 'color', {type: 'quantitative', bin: true}, 'point', defaultScaleConfig),\n          ScaleType.BIN_ORDINAL\n        );\n      });\n\n      it('should return ordinal for encoding quantitative field with a discrete channel and throw a warning.', log.wrap((localLogger) => {\n        assert.deepEqual(\n          scaleType(undefined, 'shape', {type: 'quantitative'}, 'point', defaultScaleConfig),\n          ScaleType.ORDINAL\n        );\n        assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'quantitative'));\n      }));\n\n      it('should return linear scale for quantitative by default.', () => {\n        assert.equal(\n          scaleType(undefined, 'x', {type: 'quantitative'}, 'point', defaultScaleConfig),\n          ScaleType.LINEAR\n        );\n      });\n\n      it('should return bin linear scale for quantitative by default.', () => {\n        assert.equal(\n          scaleType(undefined, 'opacity', {type: 'quantitative', bin: true}, 'point', defaultScaleConfig),\n          ScaleType.BIN_LINEAR\n        );\n      });\n\n      it('should return linear scale for quantitative x and y.', () => {\n        assert.equal(\n          scaleType(undefined, 'x', {type: 'quantitative', bin: true}, 'point', defaultScaleConfig),\n          ScaleType.LINEAR\n        );\n      });\n    });\n\n    describe('dataTypeMatchScaleType()', () => {\n      it('should return specified value if datatype is ordinal or nominal and specified scale type is the ordinal or nominal', () => {\n        assert.equal(\n          scaleType(ScaleType.ORDINAL, 'shape', {type: 'ordinal'}, 'point', defaultScaleConfig),\n          ScaleType.ORDINAL\n        );\n      });\n\n      it('should return default scale type if data type is temporal but specified scale type is not time or utc', () => {\n        assert.equal(\n          scaleType(ScaleType.LINEAR, 'x', {type: 'temporal', timeUnit: 'year'}, 'point', defaultScaleConfig),\n          ScaleType.TIME\n        );\n\n        assert.equal(\n          scaleType(ScaleType.LINEAR, 'color', {type: 'temporal', timeUnit: 'year'}, 'point', defaultScaleConfig),\n          ScaleType.SEQUENTIAL\n        );\n      });\n\n      it('should return time if data type is temporal but specified scale type is discrete', () => {\n        assert.equal(\n          scaleType(ScaleType.POINT, 'x', {type: 'temporal', timeUnit: 'year'}, 'point', defaultScaleConfig),\n          ScaleType.TIME\n        );\n      });\n\n      it('should return default scale type if data type is temporal but specified scale type is time or utc or any discrete type', () => {\n        assert.equal(\n          scaleType(ScaleType.LINEAR, 'x', {type: 'temporal', timeUnit: 'year'}, 'point', defaultScaleConfig),\n          ScaleType.TIME\n        );\n      });\n\n      it('should return default scale type if data type is quantative but scale type do not support quantative', () => {\n        assert.equal(\n          scaleType(ScaleType.TIME, 'color', {type: 'quantitative'}, 'point', defaultScaleConfig),\n          ScaleType.SEQUENTIAL\n        );\n      });\n\n      it('should return default scale type if data type is quantative and scale type supports quantative', () => {\n        assert.equal(\n          scaleType(ScaleType.TIME, 'x', {type: 'quantitative'}, 'point', defaultScaleConfig),\n          ScaleType.LINEAR\n        );\n      });\n\n      it('should return default scale type if data type is quantative and scale type supports quantative', () => {\n        assert.equal(\n          scaleType(ScaleType.TIME, 'x', {type: 'temporal'}, 'point', defaultScaleConfig),\n          ScaleType.TIME\n        );\n      });\n    });\n  });\n});\n"]}