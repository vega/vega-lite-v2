{"version":3,"file":"properties.test.js","sourceRoot":"","sources":["../../../../test/compile/scale/properties.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\n\nimport {assert} from 'chai';\n\nimport {Channel, NONPOSITION_SCALE_CHANNELS} from '../../../src/channel';\nimport {ScaleType} from '../../../src/scale';\n\nimport * as rules from '../../../src/compile/scale/properties';\nimport {AREA, BAR, LINE} from '../../../src/mark';\n\ndescribe('compile/scale', () => {\n  describe('nice', () => {\n    it('should return nice for x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('linear', c, {type: 'quantitative'}), true);\n      }\n    });\n\n    it('should not return nice for binned x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('linear', c, {type: 'quantitative', bin: true}), undefined);\n      }\n    });\n\n    it('should not return nice for temporal x and y.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.nice('time', c, {type: 'temporal'}), undefined);\n      }\n    });\n  });\n\n  describe('padding', () => {\n    it('should be pointPadding for point scale if channel is x or y and padding is not specified.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.padding(c, 'point', {pointPadding: 13}, undefined, undefined, undefined), 13);\n      }\n    });\n\n    it('should be continuousBandSize for linear x-scale of vertical bar.', () => {\n      assert.equal(rules.padding('x', 'linear', {}, {field: 'date', type: 'temporal'}, {type: 'bar', orient: 'vertical'}, {continuousBandSize: 13}), 13);\n    });\n\n\n    it('should be undefined for linear x-scale for binned field of vertical bar.', () => {\n      assert.equal(rules.padding('x', 'linear', {}, {bin: true, field: 'date', type: 'temporal'}, {type: 'bar', orient: 'vertical'}, {continuousBandSize: 13}), undefined);\n    });\n\n    it('should be continuousBandSize for linear y-scale of horizontal bar.', () => {\n      assert.equal(rules.padding('y', 'linear', {}, {field: 'date', type: 'temporal'}, {type: 'bar', orient: 'horizontal'}, {continuousBandSize: 13}), 13);\n    });\n  });\n\n  describe('paddingInner', () => {\n    it('should be undefined if padding is specified.', () => {\n      assert.equal(rules.paddingInner(10, 'x', {}), undefined);\n    });\n\n    it('should be bandPaddingInner if channel is x or y and padding is not specified.', () => {\n      assert.equal(rules.paddingInner(undefined, 'x', {bandPaddingInner: 15}), 15);\n      assert.equal(rules.paddingInner(undefined, 'y', {bandPaddingInner: 15}), 15);\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        assert.equal(rules.paddingInner(undefined, c, {bandPaddingInner: 15}), undefined);\n      }\n    });\n  });\n\n  describe('paddingOuter', () => {\n    it('should be undefined if padding is specified.', () => {\n      for (const scaleType of ['point', 'band'] as ScaleType[]) {\n        assert.equal(rules.paddingOuter(10, 'x', scaleType, 0, {}), undefined);\n      }\n    });\n\n    it('should be config.scale.bandPaddingOuter for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.paddingOuter(undefined, c, 'band', 0, {bandPaddingOuter: 16}), 16);\n      }\n    });\n    it('should be paddingInner/2 for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', () => {\n      for (const c of ['x', 'y'] as Channel[]) {\n        assert.equal(rules.paddingOuter(undefined, c, 'band', 10, {}), 5);\n      }\n    });\n\n    it('should be undefined for non-xy channels.', () => {\n      for (const c of NONPOSITION_SCALE_CHANNELS) {\n        for (const scaleType of ['point', 'band'] as ScaleType[]) {\n          assert.equal(rules.paddingOuter(undefined, c, scaleType, 0, {}), undefined);\n        }\n      }\n    });\n  });\n\n  describe('reverse', () => {\n    it('should return true for a continuous scale with sort = \"descending\".', () => {\n      assert.isTrue(rules.reverse('linear', 'descending'));\n    });\n\n    it('should return false for a discrete scale with sort = \"descending\".', () => {\n      assert.isUndefined(rules.reverse('point', 'descending'));\n    });\n  });\n\n  describe('zero', () => {\n    it('should return true when mapping a quantitative field to x with scale.domain = \"unaggregated\"', () => {\n      assert(rules.zero('x', {field: 'a', type: 'quantitative'}, 'unaggregated', {type: 'point'}));\n    });\n\n    it('should return true when mapping a quantitative field to size', () => {\n      assert(rules.zero('size', {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}));\n    });\n\n    it('should return false when mapping a ordinal field to size', () => {\n      assert(!rules.zero('size', {field: 'a', type: 'ordinal'}, undefined, {type: 'point'}));\n    });\n\n    it('should return true when mapping a non-binned quantitative field to x/y of point', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(rules.zero(channel, {field: 'a', type: 'quantitative'}, undefined, {type: 'point'}));\n      }\n    });\n\n    it('should return false when mapping a quantitative field to dimension axis of bar, line, and area', () => {\n      for (const mark of [BAR, AREA, LINE]) {\n        assert.isFalse(rules.zero('x', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'vertical'}));\n        assert.isFalse(rules.zero('y', {field: 'a', type: 'quantitative'}, undefined, {type: mark, orient: 'horizontal'}));\n      }\n    });\n\n    it('should return false when mapping a binned quantitative field to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(!rules.zero(channel, {bin: true, field: 'a', type: 'quantitative'}, undefined, {type: 'point'}));\n      }\n    });\n\n    it('should return false when mapping a non-binned quantitative field with custom domain to x/y', () => {\n      for (const channel of ['x', 'y'] as Channel[]) {\n        assert(!rules.zero(channel, {\n          bin: true, field: 'a', type: 'quantitative'\n        }, [3, 5], {type: 'point'}));\n      }\n    });\n  });\n});\n"]}