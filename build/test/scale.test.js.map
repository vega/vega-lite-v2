{"version":3,"file":"scale.test.js","sourceRoot":"","sources":["../../test/scale.test.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,MAAM,EAAC,MAAM,MAAM,CAAC;AAC5B,OAAO,EAAC,OAAO,EAAE,cAAc,EAAe,MAAM,gBAAgB,CAAC;AACrE,OAAO,KAAK,KAAK,MAAM,cAAc,CAAC;AACtC,OAAO,EACL,uBAAuB,EACvB,+BAA+B,EAAE,qBAAqB,EACtD,WAAW,EACX,SAAS,EACV,MAAM,cAAc,CAAC;AACtB,OAAO,EAAC,IAAI,EAAC,MAAM,aAAa,CAAC;AACjC,OAAO,EAAC,IAAI,EAAE,OAAO,EAAC,MAAM,aAAa,CAAC;AAE1C,QAAQ,CAAC,OAAO,EAAE;IAChB,QAAQ,CAAC,0BAA0B,EAAE;QACnC,wDAAwD;QACxD,EAAE,CAAC,yEAAyE,EAAE;oCACjE,IAAI;gBACb,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,UAAC,SAAS;oBACvC,OAAO,KAAK,CAAC,wBAAwB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC,CAAC;YACN,CAAC;YAJD,KAAmB,UAAsB,EAAtB,KAAA,KAAK,CAAC,gBAAgB,EAAtB,cAAsB,EAAtB,IAAsB;gBAApC,IAAM,IAAI,SAAA;wBAAJ,IAAI;aAId;QACH,CAAC,CAAC,CAAC;QAEH,gFAAgF;QAEhF,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,wBAAwB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;IACvE,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,YAAY,EAAE;QACrB,EAAE,CAAC,wDAAwD,EAAE;YAC3D,KAAwB,UAAiB,EAAjB,KAAA,KAAK,CAAC,WAAW,EAAjB,cAAiB,EAAjB,IAAiB,EAAE;gBAAtC,IAAM,SAAS,SAAA;gBAClB,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,SAAS,CAAC,KAAK,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC;aACrF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAGH,QAAQ,CAAC,yBAAyB,EAAE;QAClC,wDAAwD;QACxD,EAAE,CAAC,4EAA4E,EAAE;oCACpE,OAAO;gBAChB,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,UAAC,SAAS;oBACjC,OAAO,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBACrD,CAAC,CAAC,CAAC,CAAC;YACN,CAAC;YAJD,KAAsB,UAAc,EAAd,iCAAc,EAAd,4BAAc,EAAd,IAAc;gBAA/B,IAAM,OAAO,uBAAA;wBAAP,OAAO;aAIjB;QACH,CAAC,CAAC,CAAC;QAEH,2DAA2D;QAC3D,EAAE,CAAC,gEAAgE,EAAE;oCACxD,SAAS;gBAClB,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,UAAC,OAAO;oBAClC,OAAO,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBACrD,CAAC,CAAC,CAAC,CAAC;YACN,CAAC;YAJD,KAAwB,UAAW,EAAX,2BAAW,EAAX,yBAAW,EAAX,IAAW;gBAA9B,IAAM,SAAS,oBAAA;wBAAT,SAAS;aAInB;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mCAAmC,EAAE;YACtC,MAAM,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;YACpD,IAAM,UAAU,GAAG,OAAO,CAAY,WAAW,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;YAChE,KAAwB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;gBAA/B,IAAM,SAAS,mBAAA;gBAClB,MAAM,CAAC,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;aACtD;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kDAAkD,EAAE;YACrD,KAAwB,UAAW,EAAX,2BAAW,EAAX,yBAAW,EAAX,IAAW,EAAE;gBAAhC,IAAM,SAAS,oBAAA;gBAClB,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,SAAS,KAAK,MAAM,CAAC,CAAC;aACjF;QACH,CAAC,CAAC,CAAC;QAGH,EAAE,CAAC,wFAAwF,EAAE;YAC3F,wDAAwD;YACxD,IAAM,UAAU,GAAO,+BAA+B,SAAE,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,KAAK,EAAC,CAAC;YAEzF,KAAsB,UAA+C,EAA/C,KAAA,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,CAAmB,EAA/C,cAA+C,EAA/C,IAA+C,EAAE;gBAAlE,IAAM,OAAO,SAAA;gBAChB,MAAM,CAAC,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC;gBACrD,MAAM,CAAC,CAAC,uBAAuB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC,CAAC;gBACxD,KAAwB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;oBAA/B,IAAM,SAAS,mBAAA;oBAClB,MAAM,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,YAAU,OAAO,UAAK,SAAW,CAAC,CAAC;iBACxF;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,uBAAuB,EAAE;QAChC,EAAE,CAAC,wEAAwE,EAAE;YAC3E,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC;YAC/B,IAAM,oBAAoB,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;YAE9F,YAAY;YACZ,IAAI,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACxD,MAAM,CAAC,SAAS,CAAC,oBAAoB,EAAE,UAAU,CAAC,CAAC;YAEnD,YAAY;YACZ,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;YACjE,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,oBAAoB,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,iFAAiF,EAAE;YACpF,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC;YAC/B,IAAM,0BAA0B,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC;YAE5E,YAAY;YACZ,IAAI,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YAC9D,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,0BAA0B,CAAC,CAAC;YAEzD,YAAY;YACZ,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YAC1D,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,0BAA0B,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mEAAmE,EAAE;YACtE,IAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC;YAC1B,IAAM,2BAA2B,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;YAEtE,IAAI,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACxD,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,2BAA2B,CAAC,CAAC;YAE1D,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACpD,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,2BAA2B,CAAC,CAAC;QAC5D,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,oEAAoE,EAAE;YACvE,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC3B,IAAM,4BAA4B,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC;YAErE,IAAI,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACxD,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,4BAA4B,CAAC,CAAC;YAE3D,UAAU,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACpD,MAAM,CAAC,SAAS,CAAC,UAAU,EAAE,4BAA4B,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import {assert} from 'chai';\nimport {Channel, SCALE_CHANNELS, ScaleChannel} from '../src/channel';\nimport * as scale from '../src/scale';\nimport {\n  channelSupportScaleType,\n  CONTINUOUS_TO_CONTINUOUS_SCALES, getSupportedScaleType,\n  SCALE_TYPES,\n  ScaleType\n} from '../src/scale';\nimport {Type} from '../src/type';\nimport {some, without} from '../src/util';\n\ndescribe('scale', () => {\n  describe('scaleTypeSupportProperty', () => {\n    // Make sure we always edit this when we add new channel\n    it('should have at least one supported scale types for all scale properties', () => {\n      for (const prop of scale.SCALE_PROPERTIES) {\n        assert(some(scale.SCALE_TYPES, (scaleType) => {\n          return scale.scaleTypeSupportProperty(scaleType, prop);\n        }));\n      }\n    });\n\n    // TODO: write more test blindly (Don't look at our code, just look at D3 code.)\n\n    assert.isFalse(scale.scaleTypeSupportProperty('bin-linear', 'zero'));\n  });\n\n  describe('scaleTypes', () => {\n    it('should either hasContinuousDomain or hasDiscreteDomain', () => {\n      for (const scaleType of scale.SCALE_TYPES) {\n        assert(scale.hasContinuousDomain(scaleType) !== scale.hasDiscreteDomain(scaleType));\n      }\n    });\n  });\n\n\n  describe('channelSupportScaleType', () => {\n    // Make sure we always edit this when we add new channel\n    it('should have at least one supported scale types for all channels with scale', () => {\n      for (const channel of SCALE_CHANNELS) {\n        assert(some(SCALE_TYPES, (scaleType) => {\n          return channelSupportScaleType(channel, scaleType);\n        }));\n      }\n    });\n\n    // Make sure we always edit this when we add new scale type\n    it('should have at least one supported channel for all scale types', () => {\n      for (const scaleType of SCALE_TYPES) {\n        assert(some(SCALE_CHANNELS, (channel) => {\n          return channelSupportScaleType(channel, scaleType);\n        }));\n      }\n    });\n\n    it('shape should support only ordinal', () => {\n      assert(channelSupportScaleType('shape', 'ordinal'));\n      const nonOrdinal = without<ScaleType>(SCALE_TYPES, ['ordinal']);\n      for (const scaleType of nonOrdinal) {\n        assert(!channelSupportScaleType('shape', scaleType));\n      }\n    });\n\n    it('color should support all scale types except band', () => {\n      for (const scaleType of SCALE_TYPES) {\n        assert.equal(channelSupportScaleType('color', scaleType), scaleType !== 'band');\n      }\n    });\n\n\n    it('x, y, size, opacity should support all continuous scale type as well as band and point', () => {\n      // x,y should use either band or point for ordinal input\n      const scaleTypes = [...CONTINUOUS_TO_CONTINUOUS_SCALES, ScaleType.BAND, ScaleType.POINT];\n\n      for (const channel of ['x', 'y', 'size', 'opacity'] as ScaleChannel[]) {\n        assert(!channelSupportScaleType(channel, 'ordinal'));\n        assert(!channelSupportScaleType(channel, 'sequential'));\n        for (const scaleType of scaleTypes) {\n          assert(channelSupportScaleType(channel, scaleType), `Error: ${channel}, ${scaleType}`);\n        }\n      }\n    });\n  });\n\n  describe('getSupportedScaleType', () => {\n    it('should return correct scale types for quantitative positional channels', () => {\n      const type = Type.QUANTITATIVE;\n      const positionalScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT];\n\n      // x channel\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      assert.deepEqual(positionalScaleTypes, scaleTypes);\n\n      // y channel\n      scaleTypes = getSupportedScaleType(Channel.Y, Type.QUANTITATIVE);\n      assert.deepEqual(scaleTypes, positionalScaleTypes);\n    });\n\n    it('should return correct scale types for quantitative positional channels with bin', () => {\n      const type = Type.QUANTITATIVE;\n      const positionalScaleTypesBinned = [ScaleType.LINEAR, ScaleType.BIN_LINEAR];\n\n      // x channel\n      let scaleTypes = getSupportedScaleType(Channel.X, type, true);\n      assert.deepEqual(scaleTypes, positionalScaleTypesBinned);\n\n      // y channel\n      scaleTypes = getSupportedScaleType(Channel.Y, type, true);\n      assert.deepEqual(scaleTypes, positionalScaleTypesBinned);\n    });\n\n    it('should return correct scale types for nominal positional channels', () => {\n      const type = Type.NOMINAL;\n      const nominalPositionalScaleTypes = [ScaleType.POINT, ScaleType.BAND];\n\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      assert.deepEqual(scaleTypes, nominalPositionalScaleTypes);\n\n      scaleTypes = getSupportedScaleType(Channel.Y, type);\n      assert.deepEqual(scaleTypes, nominalPositionalScaleTypes);\n    });\n\n    it('should return correct scale types for temporal positional channels', () => {\n      const type = Type.TEMPORAL;\n      const temporalPositionalScaleTypes = [ScaleType.TIME, ScaleType.UTC];\n\n      let scaleTypes = getSupportedScaleType(Channel.X, type);\n      assert.deepEqual(scaleTypes, temporalPositionalScaleTypes);\n\n      scaleTypes = getSupportedScaleType(Channel.Y, type);\n      assert.deepEqual(scaleTypes, temporalPositionalScaleTypes);\n    });\n  });\n});\n"]}