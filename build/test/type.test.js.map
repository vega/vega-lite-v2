{"version":3,"file":"type.test.js","sourceRoot":"","sources":["../../test/type.test.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,MAAM,EAAC,MAAM,MAAM,CAAC;AAE5B,OAAO,KAAK,IAAI,MAAM,aAAa,CAAC;AAEpC,QAAQ,CAAC,MAAM,EAAE;IACf,QAAQ,CAAC,eAAe,EAAE;QACxB,EAAE,CAAC,mDAAmD,EAAE;YACtD,KAAgB,UAA0C,EAA1C,MAAC,GAAG,EAAE,GAAG,EAAE,cAAc,EAAE,cAAc,CAAC,EAA1C,cAA0C,EAA1C,IAA0C,EAAE;gBAAvD,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;aACnD;YACD,KAAgB,UAAkC,EAAlC,MAAC,GAAG,EAAE,GAAG,EAAE,UAAU,EAAE,UAAU,CAAC,EAAlC,cAAkC,EAAlC,IAAkC,EAAE;gBAA/C,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;aAC/C;YACD,KAAgB,UAAgC,EAAhC,MAAC,GAAG,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,CAAC,EAAhC,cAAgC,EAAhC,IAAgC,EAAE;gBAA7C,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;aAC9C;YACD,KAAgB,UAAgC,EAAhC,MAAC,GAAG,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,CAAC,EAAhC,cAAgC,EAAhC,IAAgC,EAAE;gBAA7C,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;aAC9C;YACD,KAAgB,UAAwB,EAAxB,MAAC,UAAU,EAAE,UAAU,CAAC,EAAxB,cAAwB,EAAxB,IAAwB,EAAE;gBAArC,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;aAC/C;YACD,KAAgB,UAA0B,EAA1B,MAAC,WAAW,EAAE,WAAW,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;gBAAvC,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;aAChD;YACD,KAAgB,UAAsB,EAAtB,MAAC,SAAS,EAAE,SAAS,CAAC,EAAtB,cAAsB,EAAtB,IAAsB,EAAE;gBAAnC,IAAM,CAAC,SAAA;gBACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;aAC9C;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,0CAA0C,EAAE;YAC7C,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import {assert} from 'chai';\n\nimport * as type from '../src/type';\n\ndescribe('type', function () {\n  describe('getFullName()', () => {\n    it('should return correct lowercase, full type names.', () => {\n      for (const t of ['q', 'Q', 'quantitative', 'QUANTITATIVE']) {\n        assert.equal(type.getFullName(t), 'quantitative');\n      }\n      for (const t of ['t', 'T', 'temporal', 'TEMPORAL']) {\n        assert.equal(type.getFullName(t), 'temporal');\n      }\n      for (const t of ['o', 'O', 'ordinal', 'ORDINAL']) {\n        assert.equal(type.getFullName(t), 'ordinal');\n      }\n      for (const t of ['n', 'N', 'nominal', 'NOMINAL']) {\n        assert.equal(type.getFullName(t), 'nominal');\n      }\n      for (const t of ['latitude', 'LATITUDE']) {\n        assert.equal(type.getFullName(t), 'latitude');\n      }\n      for (const t of ['longitude', 'LONGITUDE']) {\n        assert.equal(type.getFullName(t), 'longitude');\n      }\n      for (const t of ['geojson', 'GEOJSON']) {\n        assert.equal(type.getFullName(t), 'geojson');\n      }\n    });\n\n    it('should return undefined for invalid type', () => {\n      assert.equal(type.getFullName('haha'), undefined);\n    });\n  });\n});\n"]}